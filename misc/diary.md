# C(のサブセット)コンパイラ開発日記

## 2018年7月8日 (Day 1)

- VirtualBoxにUbuntuを入れるのに失敗した。しかたがないのでmacOSで開発する。まあ関数呼び出しとか実装するようになるのはもっと後の話だろうし。

- 課題1（標準入力で数値を受け取り、その数値をreturnする関数のコードを吐く）。やるだけ。入力に乱数を入れたくて、ググったとおりに適当にやったが、なんか上手く行かなかった。macOSのbashの仕様が違うのかもしれないし、私がbashを理解していないのかもしれない。両方か。

- `+` と `-` だけがあるlexerを実装。

- 課題2。とりあえずCPUをスタックマシンにするために頑張ろう。[Compiler Explorer](https://godbolt.org/)のコードを見て、見よう見まねでpushとか演算とかが実装できるようになった。チラ見した他の人のコードには普通に `push` みたいなニーモニックが書いてあったが、まあとりあえず動けばよかろうなのだ。

- lexerとスタックマシンができたのだから、あとは中置をRPNにするだけ。再帰下降パーサーを書けばいいのだが、何を思ったかshunting-yardを実装（しかもまだvectorが無いので有限長の配列）。どうせどこかで挫折するんだろうなぁ

- 無事動いた。やったぜ。

- vectorが欲しいけど、つらくかなしい `void*` よりはメタプログラミングの方がまだマシでは。

- vectorを無事shunting-yardに組み込むことに成功。これにて今日は終わり。

## 2018年7月9日 (Day 2)

- 8日の日記を書いた後に、コードをきれいにして、さらに掛け算を実装。

- 用事とか誕生日とかがあったのでそんなに組めていない。まあ今日はこんなもんでいいや。

- 新機能としては、掛け算が増え、一般に複数の優先順位にだいたい対応できたということぐらいである。どちらかというとコード美化をした一日だった。

## 2018年7月10日

- まったりしていたので進捗なし。たまにはこういう日もある。

## 2018年7月11日 (Day 3)

- まったりしていたらみなさんがとても進捗を出しているの図。

- とりあえず、パーサー拡充して演算子だけでも処理するか。演算子は大量にあるけれど代入とかを除けばだいたい同じだし。

- 除算・剰余・カンマを実装。じゃあ次は比較演算子を実装して2文字の演算子について考えることとするか

- 比較演算子( `< <= > >= == !=` ) と ビット演算子( `& | << >>` ) を実装する途中で、スペースも処理するようにした。

- 単項演算子( `! ~` )を実装したところで、そろそろ変数とかの方に移っていこうか。

## 2018年7月12日 (Day 4)

### 連想配列の実装
- 寝て起きたので日が変わっている。えーと連想配列組まなきゃなんだよな。

- `(char *, int)`というペアの配列で実装しろとのことなので、vectorテンプレートを使う。オレオレテンプレート、やはり便利。

- 実装できたと思う。テストも書いた。

### ローカル変数の実装
- ローカル変数を処理できるようにしよう。%rbpはローカル変数の処理に使うべきで、固定しておくべきっぽいので、いままで%rbpを上下させて実装していたスタックマシンを、%rspを上下させるような仕様に変更。

- 領域を確保するコードを正しく実装できた。さて次はlexerを変数に対応させよう。

- 変数に対応させようとしたら、なんか16進数と8進数が実装されていた。変数に対応させよう。

- とりあえずパーサーが変数を読めるようにした。

### リポジトリ美化

- テストファイルの命名に一貫性がないこと、自動生成されている`.s`が.gitignoreされていないことに関して指摘を受けたので訂正。

### ローカル変数の実装

- さてさて。ローカル変数の実装だ。そろそろshunting-yardだと支障をきたし始める頃だろうか。知らんけど。

## 2018年7月13日 (Day 5)

### ローカル変数の実装

- アセンブリを書いてみたところ、まあ当然右辺値として使うかどうかによって文脈判断が要るので、再帰下降にするしかないことが確定。まあそれはそうだった。最初から再帰下降にしておけばよかったのに。

### リポジトリ美化part2

- 空白はトークンではないのでlexerから削除。

- ヘッダファイルを合流させた。

- テストをまとめたり減らしたりした。
	* 出力ファイルにデバッグ情報を埋め込むことで、わざわざテストをしなくてもデバッグしやすいようになった。
	* `--lexer-debug` オプションを実装することで、わざわざテストをしなくてもデバッグしやすいようになった。
	* それによって不要になったテストを削除。`print_assembly_check009` はcheckではなくsandboxなので、そう改名。

- clang-formatを使用。

- 再帰下降で全部書き直すことに成功。

### 機能追加

- 再帰下降にしたので単項`+`と単項`-`が実装できるように。よって実装。

- 複文を実装。「最後の評価値を戻り値にする」をそのままやるのが面倒だったため、`return`も追加した。`return`の後に更に文が来たときの挙動は現状では未定義とする（実情としては、「評価されるが」返り値には影響を与えない、みたいな挙動になるはず）→ラベル足せばいいことに気づいたので足す。

- 変数aと変数bを使って処理ができるように。

- 任意の名前の変数を許容。

- `^`を実装、さらに条件演算子を実装。

## 2018年7月14日 (Day 6)

### 関数呼び出し

- 関数呼び出しを実装。関数定義ができないので、常に`87`を返す組み込み関数`always87()`を実装することで凌ぐ。

- 引数付きの関数呼び出しを実装。

## 2018年7月15日 (Day 7)

- `parse_compound_statement` を足して、それで全体をparseするように。

- 複数の関数定義（引数なし）をパースできるように。

- 複数の関数定義（引数あり）をパースできるようになり、フィボナッチに成功。

- `&&` を実装。`3 && 2 && 5`とかでも通る。

- `||` を実装。`3 || 2 || 5`とかでも通る。

- `+=` を実装。

- `-=` `*=` `/=` `%=` `<<=` `>>=` `&=` `^=` `|=` を実装。

- `if` - `else` を実装。ちゃんと最も内側の`if`に`else`がくっつく。

- 関数内に複数のルートができたということなので、同一関数内の`return`は必ず同じ場所に返るように修正。

## 2018年7月16日

- 徹夜 → 15:00まで外出 → ( ˘ω˘)ｽﾔｧ

## 2018年7月17日 (Day 8)

- `do` - `while` を実装。

- `while` を実装。また、`;`とコンマ演算子はやっぱり挙動が異なるべきなので、修正。

- `break` を実装。多分。二重ループでもちゃんと正しく動いてるっぽいのでOK。

- `continue` を実装。

## 2018年7月18日 (Day 9)

- バグが検出されたので直した。do-whileの末尾でスタックを余計に押し下げていて、ローカル変数の領域を破壊していたのが原因だった。

- いい加減vectorを`void *`に統一しなければならないので、その移行の準備をした。

- 前置・後置の`++` と `--` を実装。

- 「lexerを2回実行して、1回目でトークン数を数えて2回目でその分をcallocする」とすれば `vector_Token` が不要になるので、そうした。

- intmap以外でのvectorの使用を廃することに成功したので、vectorをintmapの中に放り込んで怒涛のinline化。そしてリポジトリからテンプレート機構を削除。

- 第三式が無いfor文を実装。

- 第三式があるときにもfor文を実装。（あれ、コメントアウトで書いているけど2重ループでマズいのでは）（←大丈夫。第三式自体にforが出なければよくて、forは文なので第三式には出てこない）

## 2018年7月19日 (Day 10)

- ソースコードから配列を追放。これで多分すべての変数宣言が `型名 名前;` と見なせる

- `型名 名前;` を構文解析

- `int_map` は `int` じゃなくて `void*` を取るように。それに沿って `map` に改名。

- 変数が宣言されていないとエラーになるようにした。

### スコープ

- ちゃんとスコープを見てやらねばなのである。ということで、現状の `map` での管理では限界があろう。ブロックの内外で変数名が衝突することもあるのだし。

- 変数用の領域を確保する処理は割と現状のままでよくて（現状だと多めに取ることになるが、多い分には困らない）、名前解決を直さねば。

- 現状では、関数に入る際に、それ以降に登場する全ての識別子を数え、それに `offset` を振っている。しかしこれだとスコープの内外で変数名が衝突したときに困るので、最初は全ての識別子を重複を含めて数え、 `offset` は振らないでおく。

- まずデータ構造を考えよう。中から外を見なければいけないが、外からは中は見えなくて良い。ということで、外へ外へと伸びていくリンクリストにすればよさそうではある。

- さてどう移行していこうか。とりあえず `var_table` を `old_var_table` にしよう。次に、 `capacity` の確保をする際には重複して数えるようにしよう。

- とりあえず片方向リンクリストの型を入れておいた。まだリンクリストにはなっていないけど。

- `isDeclared` を一旦捨てて、直に `offset` を`void*`にキャストする方針へ。これにより`calloc`を廃す。

- 宣言されてから初めて`insert`するようにした。動いた。

- 多分リンクリストが実装できた。知らんけど。

- スコープチェーンが動いていることを確認。

### 雑多

- ついでに、関数名の前に型を要求。これで `supplement.c` を自力でコンパイルできるように。

- 誤ったCに対してエラーを吐く方に関してはテストをしていなかったので、テストをしようとしたところ、continue_label_nameの初期化忘れというバグを検出。修復した。

### 型とoffsetとアラインメント

- 言われたとおり、 `Type` 型を追加。ついでに幅を取得する`size_of`を追加。

```c
struct Type {
	enum { INT_, PTR_ } type;
	struct Type *pointer_of;
};
```

- ポインタ型の宣言を構文解析。

- ポインタ型の値を後々入れていくことも考え、offsetを一律8に。

## 2018年7月20日 (Day 11)

- `&` と `*` を実装していきたい。とりあえずアセンブリで実験を重ねる。

- ↓をアセンブリでどう吐くかが分かってきた。

```c
int main()
{
    int x; x = 86;
    int *y; y = &x;
    int **z; z = &y;
    return (*y) + (**z) + 2;
 }
```

- 変数に型情報が必要なので、 `struct VarInfo` を復活させた。といっても、かつてのとは異なり `isDeclared` が滅びているわけだが。そして変数の型情報をinsert。

## 2018年7月21日 (Day 12)

- 型のsizeが8バイトであるときは8バイトをロードするように。

- とりあえず `&` を足すだけ足した。

- 型チェックをするには型の等価性を判定しなくてはいけない。ということで `type.c` を分離してそこに書いていくことにする。

- んー、コンパイラの中にも「型のスタックマシン」を積んで、それを操作して型情報を取得するしかないな。普通なら抽象構文木をちゃんと作って処理するべきなんだろうけど、いまさら足すのもなぁという思いがあるので。

- 現状の `gen_` 系の関数を全てラップするか。んでコンパイラではそっちを呼び出す感じで。

# これ以降日記の更新が途絶えており、1ヶ月経った今（2018年8月21日）ログを見て書いていっている

- 言語学オリンピックの集まりに行った後、[radare2のコミッター](https://twitter.com/Vane11ope)とか[SecHack365経験者](https://twitter.com/megumish)とかとのオフ会に行く。上記の「型のスタックマシン」のアイデアをもとに午前中12コミットほどするも、午後6時台に（時間を潰すべく座る場所を求めて行った）ゲーセンで2コミットしたタイミングでこの方針の愚かさに気づき、急遽午前9:38の4ade413に戻すこととした。

- なお、戒めのためにそのブランチをdesertedという名前でpushしておく。

- コミッターと合流した後もコードを書いていく。とりあえず、desertedブランチのなかでも使い物になりそうなコミット（本筋と関係のなかったコード美化のたぐい）を採用してから、implement_typecheckブランチを立ててやっていった。

### 型チェックの実装

- とりあえず、（理想に反して）まだ構文木が無いので、parse_なんとか_expression系の関数（なんとparseといいながらここで意味解析もコード生成もしているんよな）がvoidではなく式の型（とあとは「ローカル変数かどうか」「ローカル変数だったときそのオフセットはどれほどか」）を含む構造体ExprInfoを返すようにしていった。

- 一気にやるとバグらせるので、一時的にFIXMEという値をExprInfoとして許容し、1関数ずつExprInfoを足していきながら情報が足りないときにはFIXMEで埋める、という方針をとった。この方法は今後も何回か出てくる。

- この日のうちにはFIXMEを消し去るところまで行かなかった。21:00頃に二次会（radare2のコミッターがTwitterで人を追加で呼び急遽開催）が発生し、その後帰って寝たからである。なお、[ログ](https://twilog.org/hsjoihs/date-180722)曰く進捗も出さずに午前2時までTwitterをしていたそうな。

## 2018年7月22日 (Day 13)

- [ログ](https://twilog.org/hsjoihs/date-180722)曰く、起きたのは13時とかのようだ。コードは15時から書き始めている。16時あたりに「通るはずの型チェックが通らない」という現象が起きたらしく、それを特定すべくexpect_typeの第三引数にマジックナンバーを埋め込んでデバッグ、2項&が単項&と衝突するらしいのでとりあえずコメントアウトして4e311d8としてコミット。（おかしいなー再帰下降してるんだから衝突なんて起こるはずないのになー）原因は関数のパラメータに関して型の情報を記録していなかったというだけだったのだが、埋め込まれたマジックナンバーはその後も残り続け、後にコードレビューで指摘されることとなる。

- FIXMEを全て取り除いた。この段階でテストを走らせると089だけが通らない。仕方がないので089をコメントアウトしてコミット。

- アドレス演算子のパーサーでポインタを進め忘れていたというだけの話だった。「通るはずの型チェックが通らない」という現象が起きていたのは、このせいで2項演算子の&の方の処理も通っていたためのようだ。なるほどなぁ。これにより、「パーサー中で変なところを通っていたら、トークンの消費し忘れ=ポインタの進め忘れを疑え」という知見を得た。これは地味に後々のデバッグで役立つのであった。

- ということで無事実装できたので、implement_typecheckブランチをmasterにマージ。

### 間接参照演算子・複雑な左辺を持つ代入文の実装

- 型チェッカーができたので、「右辺値としての」 `*` の実装は楽である。ポインタ型であるかどうかを確認して（←これを書くために型チェッカーが必要だったのだなぁ）、PTR_ノードを型から取り除いて、アドレスから値を得ればOK。テストも通る。

- さて、問題は左辺値である。自分でもあまり分かっていなかった印象があったので、恒例のごとくとりあえずgccが吐いたアセンブリを読んで式変形していこう。

## 2018年7月23日 (Day 14)

- 複合代入演算子も考えておいたほうがいいよなぁ。これまたアセンブリを読んでいこう。ふむふむ、先に右辺値として処理する際に、`*`される前のアドレスを隠しローカル変数に退避しておけば、「実は左辺値でしたー」となったときも対応できるな。さらに、複合代入演算子の場合は右辺値としての値と左辺値としての値が両方必要になるわけだ。ますますこの方法が適しているだろう。

（編注：当然であるが、構文木さえ作っていれば、こんなトリック使わずとも「右辺値と左辺値のコード生成を分離する」だけで十分なのである。）

- 寝て起きた。ということで、ローカル変数の領域を増やしてアドレスをバックアップしよう。（編注：なぜか44e2c5dのコミットメッセージはback up the **register** とか書いてある。addressの間違いに決まっているんだよなぁ。）

- Cの構文規則では、assignment-expressionはこう定義されている。

```
assignment-expression:
                 conditional-expression
                 unary-expression assignment-operator assignment-expression
```

- ということは、「試しにunary-expressionを読んでみて、その直後にassignment-operatorが来ていなかった場合はその情報を破棄し、conditional-expressionとして読む」と実装しなければならない。しかし、現状ではparseしたら同時にコード生成もしてしまう。

- コード生成のオンオフを切り替える機能を実装することも一瞬考えたが、あまりに面倒である。かといって、ネストする可能性があるのでfor文のときと違ってコメントで処理はできない。

- …そうだ、ジャンプですっ飛ばせば事実上のコメントアウトではないか！

（編注：当然であるが、構文木さえ作っていれば、こんなトリックは一切不要なのである。）

- とまあそんな迷案を思いついてしまったので実装。ついでにfor文の第三式もコメントではなくこの方法で処理するように。

- `*ident` とかがlvalueとして使えるようになった。

- assignment-expressionがネストする際、バックアップ領域が上書きされてしまうのを防ぐために、バックアップをさらにスタックに積み直すように。これにより `a = b = 5;` が動く。

（編注：当然であるが、構文木さえ【以下略】）

### `alloc4` のための準備

- さて、資料に従ってポインタ演算のテストをするには、「intの値を4つ引数に与えるとその引数を要素数4の配列に突っ込んでくれる」という関数alloc4を作ってgccでコンパイルし、リンクする必要がある。そのためには関数にポインタを渡したり、関数からポインタを返したりする必要がある。関数呼び出し周りが4byteの引数しか対応していないので、修正が必要だ。

- アセンブリを眺め、「あっこれ `movq` にしないとダメだな」とかを検出しつつ、コード片を `print_x86_64.c` に送っていく。

- ポインタを関数に渡したりとかをできるようにすべく、そのための8バイト用コード片とかを足した。

- ParserState が関数の戻り値の型をメモるようにしたので、戻り値の型チェックができるようになった。

## 2018年7月24日 (Day 15)

- 他の関数の戻り値の型を `func_ret_type_map` というmapに入れておいて、呼ぶ方も型チェックをするように。ん、となると、資料に書いてある `alloc4` を実現するにはプロトタイプ宣言を足さないといけないな。

（編注：当時の資料のalloc4は確保した配列をポインタで返していた。int以外の値を返しているこのような関数を書くにはプロトタイプ宣言が必要ではないかと指摘し、今では「`alloc4`の第一引数に`int **`を渡し、そこ経由でポインタを入手する」ように書き換わっている。）

- 8バイト用コード片を足したのでポインタを関数から返せるようになった。

- 前述の理由によりプロトタイプ宣言を追加。

### ポインタ演算

- ポインタ演算を実装すべくgccの吐いたアセンブリで実験。 `cltq` という命令について学ぶ。

## 2018年7月25日 (Day 16)

- ポインタ演算（pointer + int）を実装。ちなみにこの段階で`alloc4`の呼び出しが16バイトアラインメント制約に抵触しており、手動で変数を足してアラインメントをアドホックに揃えている。

- 16バイトアラインメントを必ず満たすようにする方法を考える。思いついたのは以下の方法。
	- まずスタックを8バイト伸ばす。
	- rspと15でbitandし、rspを16で割ったときの余りを得る。
	- その余りの分だけスタックを伸ばし、余りをスタックのトップに格納してからcallする
	- 戻ってきたら、スタックのトップに書いてある値の分だけスタックを縮める。
	- スタックのトップに戻り値を書き込む。
- こうすれば、最初に伸ばした8バイトのところに必ず戻り値が書き込まれ、かつcallの直前には必ず16バイトにアラインされている。

## 2018年7月26日 (Day 17)

- pointer - intとかint + pointerとかも実装。

- ポインタ演算のために掛け算するsizeofは1, 2, 4, 8だけ考えていればいいと思い込んでいたが、よく考えると配列へのポインタに関してはその限りではない。ということで任意のサイズを許すように。

## 2018年7月27日

- ログを見る限り、徹夜してTwitterをして東大に行ってオフ会をしている。昼頃に人と会い、15:46頃に人が漢詩を作っている（押韻と平仄に苦しんでいた）のを見たりして、19:00あたりまで寝て、一人と会って帰っている。Cコンパイラの進捗は皆無である。

## 2018年7月28日 (Day 18)

### 配列

- 配列を実装することを考え始める。まずは構造体Typeで配列を扱えるようにするのが先決だ。

- 現状の関数定義のパーサー（もちろんコード生成と混じっている）は `ret_type func_name(arg_list){}` の形にしか対応していない。これを読んでいる人の中には「えっ、Cの関数定義の構文ってそうじゃないの？」と思っている人もいるかもしれないが、そうではない。例えば、 `int a[3][5];` で定義される2次元配列 `a` を関数に渡し、関数では渡された `a` をそのまま返しているとしよう。その場合、その関数の定義は

```c
int (*func(int (*a)[5]))[5]
{
    return a;
}
```

または

```c
int (*func(int a[3][5]))[5]
{
    return a;
}
```

となる。

- 今までは `int *foo()` というのを「型名 `int *`を読んで、識別子を読んで、カッコを読む」としていたが、配列が入ってくるとこれは破綻する。

- ここまで複雑な例でなくても、「配列へのポインタ」を書きたいだけでも `int (*a)[5];` と書かねばならない。配列の構文をサポートしろと書いてあるのだから、こういうケースもちゃんとサポートしてやらねばならない。

（編注：後になって分かることだが、この理解は **誤り** であった。資料には「 `int a[10];` のような変数定義を読み込めるようにしてください。」としか書いておらず、配列へのポインタだったりそれを返す関数だったりの構文解析をしろとはどこにも書いていない。）

- なら、いっそのこと型関連の純粋なパーサーを新規に書き下してやろう。そうすれば現状の「パーサーとコード生成が混じっている」という現状を改善する取っ掛かりにもなるだろう。

- `int *a;` とかを読んでいた箇所では、今までは `int *a` 箇所を「型名 + 識別子」として読んでいた。しかし、この解釈は誤りであるので、この箇所を `parse_var_declarator` という名前で抜き出し、構文規則に合ったコードで再解釈していくことを目標とする。

## 2018年7月29日 (Day 19)

### ローカル変数の容量

- 「スコープ」のところに「現状では、関数に入る際に、それ以降に登場する全ての識別子を数え、それに `offset` を振っている。しかしこれだとスコープの内外で変数名が衝突したときに困るので、最初は全ての識別子を重複を含めて数え、 `offset` は振らないでおく。」などというすごいことが書かれている。これは、「構文解析とコード生成を同時に行っている以上、関数が要求するローカル変数用の領域の大きさが関数の最後までわからない」という本質的な課題から逃げるための一時しのぎである。

- しかし、配列が入ってくると、識別子の数を数えたところで十分な領域が確保できるとは限らなくなってしまう。ということは、関数を末尾まで読んで初めてローカル変数の容量が確定する。しかしローカル変数用の領域は関数の先頭で確保される。さてどうしよう。

（編注：当然であるが、構【以下略】）

- そうだ、領域を確保するコードは関数の末尾に書いて、関数の先頭にはそこに飛ぶラベルを書けばいいんだ。（←は？？？？）汚いけど動くからセーフ。うんうん。

（編注：アウト。いやまあfor文の第三式をコメントアウトで処理し始めた時点で既にだいぶアウトだった感は否めないが）

- ローカル変数のsizeに応じてスタックを確保するようにした。前は最高が8だったので識別子が出るたびに8だけ確保していたが。

### 型の構文

- [「さて、配列とポインタの入り混じった型宣言を構文解析するコードを書かねばならない」](https://twitter.com/hsjoihs/status/1023545042281975808)とかツイートしている。結論から言えば、しなくてよかったんですけどね。

- 「型名 + 識別子」は嘘なので、 `parse_type_name` とかいう関数をinlineして `parse_var_declarator` として処理していくように。アスタリスクは識別子の方にくっつくのだということを `parse_var_declarator` に教えていきたい。

- `parse_var_declarator` は `ptr_ps` も コード生成も含まない純粋なパーサーなので、 `type.c` に送る。

- K&Rを参考にして、 `parse_var_declarator` から `parse_dcl` （`*a` を処理）を分離したり、アスタリスクは先に数えるだけ数えて後で型を構成したりするようにした。

- `parse_dcl` から `parse_dirdcl` を分離。

- `parse_dirdcl` にカッコを許容。（ `int *(*p);` とかが書けるように。）

- そういえばlexerにまだ角括弧を教えていなかったので追加。

## 2018年7月30日 (Day 20)

- 日付は変わって7月30日。もう7月も終わる頃か。

- 配列型のパースをバグらせた（pushしていないのでGitHubからは見えないはず）ので、typeparse_check.cを追加してチェックしながら慎重にやっていこう。

- K&Rでは、型の構成要素が決まるたびにprintfしていっていた。つまり、vectorを用意してやって、K&Rがprintfしている箇所でvectorにプッシュしてやれば正しく動くはずだ。（ちなみにこれに気づくまでにさらに1回バグらせている。もちろんpushしていない。）

- 三度目の正直で、配列を正しく読めるように。

### 構文解析とコード生成の分離（part0: 型）

- 配列が読めたなら関数も同様に読める。じゃあ現状の関数定義のパーサー（もちろんコード生成と混じっている）もこれで処理するようにしてやれば、そのうちグローバル変数を実装した際にも対応できる。まずは `int *foo(){}` で生き残っていた `parse_type_name` とかいう関数を滅ぼし、後にグローバル変数に使うことも考えて `parse_function_definition` を `parse_toplevel_definition` に改名。

- 関数型を追加して、純粋なパーサーで関数定義部分を読み取るように。`parse_toplevel_definition` の先頭での処理を純粋なパーサーに置き換えてやることで、可読性が上がりながらパーサーの「「「正しさ」」」も上がった。よきかな。

- 前は `parse_parameter_declaration` でパースとコード生成を両方やっていたが、パースは純粋な方がやることになったのでコード生成のみの関数を生むことができた

- きれいに「パーサーが読む、コード生成箇所が吐く」を（少なくともこの関数定義の冒頭に関してだけは）行うことができ、パーサーとコード生成を分離していくことに対する良い前例が生まれた。「パーサーが読んだ型が関数型以外であればグローバル変数宣言である」なので、今後グローバル変数を足していく際にもきれいに足せる。

- 今回の件で、構文解析とコード生成が分離していることが如何に素晴らしいかだんだん分かるようになってきた。ということで、今まで `parse_` で始まっていた関数の内、コード生成もしているものに関しては `parseprint_` という接頭辞にしてやることで、「いつかは分離してやるぞ」という思いを表すことにした。

- もともと変数の処理しか考えていなかったので `parse_var_declarator` と名付けたが、関数も対応した今となっては `parse_declarator` のほうがいいだろう。 

## 2018年7月31日 (Day 21)

- `parse_var_declarator` は変数専用にしよう。ローカル変数の確保とか。（関数内部にもプロトタイプ宣言は書けるけど、ローカル変数の「定義」と違って領域を確保しないので、こういうのは `parse_var_declarator` にして、関数内にプロトタイプ宣言書くのは現状では禁止しておこう）

- 他に変数専用なのは…ああ関数の引数とかか。関数の引数は関数ポインタであって関数ではないもんな。（仕様を見る）えっ？関数型を渡すのは合法で、勝手に関数ポインタになってくれるの？知らなかった。あ、ついでに「引数が配列型なら勝手にポインタに読み替えられる」を足しておこう。

（編注：史実としては、この仕様を知ったのは[前日](https://twitter.com/hsjoihs/status/1023859943806361600)である。）

- #pragma onceを消した。

### グローバル変数

- 資料に従うと、次に足したいのはグローバル変数なので、VarとなっているやつをとりあえずLocalVarとしておこう。あと、グローバル変数がどうコンパイルされるのかも実験せねば。

## 2018年8月1日 (Day 22)

- `gen_write_to_global_8byte`, `gen_write_to_global_4byte` などのスニペットを定義。

- ヘッダファイルはなるべく一つにまとめるよう言われているが、 `print_x86_64.c` に関しては「長い」「コンパイラの他のコードと完全に独立している（構造体の定義を要求しないなど）」「`print_x86_64.c`で定義されている関数を要求する.cファイルが限られる」という理由から、分離することを確定。

- グローバル変数の定義・グローバル変数の名前解決を実装。

- Rustに触発され `unimplemented` 関数を追加。`fprintf`して`exit`するだけ。

- 右辺値としてのグローバル変数・左辺値としてのグローバル変数を実装。

## 2018年8月2日 (Day 23)

### 構文解析とコード生成の分離（part1.1: 式のパーサー純化）

- 式に関して純粋なパーサーを書き始めるようにする。まず、`parseprint_expression.c` をコピペしてコード生成にまつわる部分を全てコメントアウトし、 `parse_expression.c` を作る。

- 式パーサーの中でも`parse_expression.c`ではなく`compiler.c`に置いてあるやつに関しても複製。

- for文の第三式は、今回作った「コード生成しないパーサー」を使うことでジャンプコメントを回避。最初からこうしておけ。また、これにより（多分きっとおそらく）コード生成箇所が抜かり無くコメントアウトできていることを確認。

- 代入文のところもジャンプコメントを回避するようにしたところバグった。検証してみると、やっぱりコメントアウト忘れが発覚したので直す。

- まずXOR式をASTにしていって、そこから順次ASTにしていく。前回と同様、未実装のところはUNKNOWNで埋める。ビット積→等号→比較→シフトまでやって、問題は次の加減算である。

- 式のカテゴリにPOINTER_PLUSORMINUS_INTを足した。意味解析が構文解析側に融合している現状では、パーサーを通したらいきなりコード生成となるので、式のカテゴリとして処理してやる必要がある。POINTER_MINUS_POINTERも要りますわな。

- あとは乗除→ビットOR→論理AND→論理OR→条件演算子。論理AND・論理OR・条件演算子は今までラベル生成があったので`parse_expression.c`から外されていたが、純化により分ける必要がなくなった。

- さて、残るは関数の引数（パーサー上はassignment_expressionであり、あとで統合される）とか、変数や数値リテラルといったprimary_expressionとか。

- 代入演算子。ローカル変数への代入・グローバル変数への代入を実装。

- 単項演算子→後置演算子→関数の引数リスト→関数呼び出し。これでUNKNOWNの廃止に成功。

- parse_expressionは2項演算子のみを処理しているので、parse_binary_expressionに改名。その他の純粋パーサーはparser.cとしてcompiler2.cから分離。

- 引数の長さを数え間違えていたバグを修正。

- parseprint_expressionをいずれはprint_expressionにすべく、print_expressionを部分的に実装。print_expressionを使ってパースせずにコード生成することが可能かどうか判定するis_parse_implementedも作る。これにより、段階的移行が可能になる。

### 構文解析とコード生成の分離（part1.2: 式のコード生成純化）

- とまあ、65コミットを要する大改造を経て純粋なパーサーを作ることができた。最初から分けておけばよかったのに。

- さて、まだ終わっていなくて、parseprintから純粋なprintを作ってやらねば分離したことにはならない。

- parseprint_expressionでのトークンの消費をするのにparse_expressionを使うように。少なくともトークンを正しく消費できていることは確認ができる。

- primary_expressionで数値リテラルを読む際、INT_VALUEカテゴリを付け忘れていたバグを修正。

- print_expressionを少しずつ実装できているので段階的に移行。テストは常に通るべきなので、「完全分離でできている」は緑、「できていない」は赤でメッセージを吐きながら、赤を減らしていく方針。

- 単項演算子を足したので021まで完全分離。

## 2018年8月3日 (Day 24)

- print_expressionに機能を足していくごとに、026まで→036→038→073→088→089→104と、どんどん分離できるようになっていく。

- もはや「分離できている」が当たり前になってきたので、ここらで緑メッセージを削除。

- ポインタ演算のコード生成も実装し、完全分離に成功。さて怒涛の削除の時間だ

### 美化・微調整

- 大量にコードを削除したり、Expressionの中で使う演算子用のenumを分離したり、コードを美化したり。徹夜をしているのでロジックとかは書くべきではなく、単純な式変形として実装できるタイプのリファクタリングに限るべきである。

- 加減算の処理は複雑だが、多くの演算子に絡む。ということでcombine_by_add_or_subという関数として分離。

- 配列を左辺値として使えないように。

### 配列からポインタへの暗黙の変換

- アセンブリで実験し、ローカル変数の場合での実装に成功。

- 次は「配列へのポインタ」を間接参照してできる配列。これまたgccのアセンブリで実験だ

- MACOSフラグをソースコードではなくコンパイラオプションとして渡すように。調べたらMakefileで自動判別できるっぽいので採用する。

- VirtualBoxの導入になんか成功したので、このリポジトリをUbuntuに持っていったところ動かない。どうやら、アセンブラの仕様が違うらしく行途中のコメントに対応していないようだ。あと`+8(%rsp)`と書けないらしい。

### グローバル変数のアドレス

- gen_global_declarationで出てくる_はMacだけなので、PREFIXマクロに置き換え。

- グローバル変数のアドレスを得るには、MacだとGOTPCRELとかいうものを使わないといけないらしい。Ubuntuはleaqでいいので気楽である。ということでgen_push_address_of_globalを書いて両方の環境でテストした。

- 徹夜が堪えてここで仮眠。

- アドレス演算子をグローバル変数に対応させた。

- グローバルな配列がポインタにすり替わるように。

### 左辺値

- 「配列へのポインタ」を間接参照してできる配列が、これまたポインタにすり替わるように。

- せっかくコード生成と構文解析が分離したのだから、`print_expression`と分離した`print_expression_as_lvalue`を実装すべきだという気持ちになった。とりあえず`print_expression`のサブセットを作るところから始める。

- 例の一時しのぎ「「「アドレスのバックアップ」」」の処理が必要なのはprint_expression_as_lvalueの場合だけであるので、そちらにその処理を送る。これにより左辺値と右辺値のコード生成が別物になった。

- 13コミットぐらいひたすらアセンブリを式変形し、`gen_assign`という共通処理をくくりだすことに成功。

- 諸々リファクタリング。「=はコンマ演算子による複合代入演算子」と解して処理のさらなる共通化に成功したこととか。

## 2018年8月4日 (Day 25)

- LOCAL_VAR_AS_LVALUEが`print_expression`に到達しないことを確認。AS_LVALUEとAS_RVALUEを合流させても問題なさそうだ。

- 三種の左辺値（ローカル・グローバル・間接参照されたアドレス）の処理を一体化。

- 「「「アドレスのバックアップ」」」を完全に消去。

## 2018年8月5日 (Day 26)

### 2次元配列とNクイーン

- なんか2次元配列で微妙にバグってるっぽい。添字0のときは問題ないので、sizeof絡みででもミスっているのだろうか。とりあえず恒例のごとくgccにアセンブリを吐かせて実験だ。

- 「配列へのポインタ」を間接参照する際は、その値は変わらないということに気づいた。なるほどなぁ。さてこれで2次元配列もフルで動くようになった。

- AS_LVALUEとAS_RVALUEを合流させた。

- Nクイーンが解けるようになった。

## 2018年8月6日 (Day 27)

- やはり毎回`*(p+i)`とか`*(*(p+i)+j)`とか書いているのはつらいので、添字演算子を足そう。`combine_by_add_or_sub`は既にあるので、間接参照演算子用の`deref_expr`を作る。

- `p[i]` を実装。

### 構文解析器の内部状態とコード生成部分の内部状態の分離

- 構文解析時には、コード生成部分の内部状態は見えるべきではない。ということで`PrinterState`という引数を生やしてコード生成部分の関数で持ち回り、ラベルとかの情報はそちらで持つようにしよう。

- コード生成部分は構文解析器の内部状態を見るかもしれないが、変更はすべきでないだろう。constを足す。

- 実はコード生成部分は構文解析器の内部状態を見る必要がなかったようだ。引数から削除。

### char

- 資料によれば、次はcharらしい。とりあえずgccのアセンブリをいじるいつもの作業。

- 1byte用の関数を追加。

- 末尾に4byteとついていなかった関数の多くに4byteとつけていく作業。

- lexerと型パーサーにcharを足す

- intとcharの間で代入ができるように、is_equalをis_compatibleとis_strictly_equalに分離。

## 2018年8月7日 (Day 28)

- `char *`のderefとか、グローバルなcharとか、charの符号拡張とかを足す。

- `leave` - `ret` するだけでいいことを知り、実践。

- charが関数に渡せるようになったりする。

- lexerに文字列リテラルを追加。

- スタック上では少なくとも4バイト分は符号拡張されているようにした。

- gen_strとgen_push_address_of_strをとりあえず足す。OSXでもUbuntuでも動くことを確認。

## 2018年8月8日 (Day 29)

- 文字列リテラルをparse→コード生成したのでprintfを呼び出すコードが通る。

- せっかくなので、Nクイーンでprintfを使うサンプルを追加。改行のためのエスケープシーケンスは無いので `puts("");` で対応。

## 2018年8月9日 (Day 30)

### ミーティング

- ミーティングが行われた。指摘された箇所を直していったりしよう。

- .gitkeepを使う→過去の遺物を削除→.hにclang-formatを掛ける→無駄なカッコの削除→未使用関数の削除

- expect_typeの第三引数がマジックナンバーになっている（7月22日参照）のをデバッグメッセージに変更

- ExprInfo.details.infoが重複した情報であり省けることが判明。削除。それに従い、remove_leftinessあたりの関数が消えた

- `int (*func(int (*a)[5]))[5]` とかに対応する必要は全く無いとのことなので、それの処理をするコードを削除。故にtypeparse_check.cも不要に。

- あと延々とリファクタリングが続くので、細かいものに関してはカット。

- 特筆すべきこととしては、関数に`static`を付けることを避ける理由はないとのことだったので追加。

- さらに、かつて滅ぼしたvectorを復活させた。あと型名は大文字で始まるように。

- `+` と `-` は取る型が違うので、`combine_by_add_or_sub`を`combine_by_add`と`combine_by_sub`に分割。

- 複数行コメントに対応。

- compiler2.c → codegen.h + main.c + codegen.c

- 今まで入力をscanfで一行だけ読んでいたのを、複数行にも対応させる。

### 構文解析とコード生成の分離（part2: 文）

- 文に関しても構文解析とコード生成を分離させていく。まずはparseprintの戻り値をvoidではなくstruct Statementにするところから。今回も恒例のごとくNOINFOというを足して再帰的に機能を追加。

- NOINFO自体は8コミットぐらいで廃止できた。式ほど再帰が深くないのが助かる。

## 2018年8月10日 (Day 31)

- newest_offsetはコード生成の内部状態にしていたが、構文解析（というか意味解析）の側に置いたほうが扱いやすいので移動。

- これまたparseprintをコピペしてコード生成を削除することでparseを作る。

- assertを入れ、消費するトークン数が同じであることを確認するのも恒例の通り。

- parseprint_statementが引数として（自分自身が今returnしている）Statementを受け取るように。コピペしているのでこういうこともできる。

- parseprint_statementが（パーサーの条件によってではなく）Statementの条件によって分岐するように。

- parseprint_statementがvoidを返すように。

### 16進と8進の削除

- 消せと言われたので消す。

### 構文解析とコード生成の分離（part2: 文）続き

- codegen_expressionを作ってcodegen.hから分離する。

## 2018年8月11日 (Day 32)

- 純粋なコード生成器print_statementが少しずつできてくる

- 一時的にスコープチェーンのコピーを作る必要ができたので、これを機にMapに手を入れて内部構造を隠蔽する。

- スコープチェーンのコピーをこっそりメモしておくことにより、parseprint_compound_statementでも「自分がparseして得たstatement」ではなく「純粋パーサーがparseして得たstatement」を使うことができた

- [parseprint_statementをparse_statementとprint_statementに分離することに成功](https://twitter.com/hsjoihs/status/1027990934024151040)。

- 分離してコードの順序を入れ替えた途端にスコープチェーンのバックアップが不要になった。

- codegen.cからparse_statement.cを分離

- parseprint_function_definitionもparseとprintに分離

- parse_function_definitionをparse_toplevel_definitionとし、変数の場合も吸収。parse_definition.cとして分離

- 全てのコード生成からParserStateの排除に成功

- main.cでもparseとprintを分離。tokenizeしてparseしてgenerateする流れになった。

## 2018年8月12日 (Day 33)

### 美化

- enumの型名を大文字で始める

- GARBAGE_INTを取り除く

- テストケースをシェルスクリプト送り

- パーサー周りをparser.hに隔離

- ParamInfosをVectorで代用する

## 2018年8月13日 (Day 34)

- 予約語処理を別関数に分離

- 指摘されたとおり、トークンが文字列の途中へのポインタを持っておくことで短いコード量でデバッグ出力をすることができるので修正。

- ファイル名変更したり重複を削除したり。

## 2018年8月14日

- セキュキャン1日目。人と話したり人の話を聞いたりしてたのでコードを書いていない。

## 2018年8月15日 (Day 35; Seccamp Day 2)

### インクリメント周り

- 左辺値の処理をまとめたりパーサーに手を入れたりすることで`++*ptr`とか`((i))++`とか`p[i]++`とかを許容。

### バグ修正

- バグ修正：レジスタに退避するタイミングを間違えていたことによって `foo(i, j, bar(k))` が`foo(k, j, bar(k))`になってしまっていたバグを修正。

- 条件演算子のオペランドが4バイトと仮定していたことによるバグを修正。

### コード美化

- ファイル名変更。parse_expressionとparse_binary_expressionを合流させたことによって関数に追加でstaticをつけられるように。

- 構文解析と意味解析を分けるべきだということを明示すべく、`parse_*_expression`を`parse_typecheck_*_expression`に改名。

### 機能追加

- `&*p`, `&(*p)`, `&(q)`を許容

### 構文解析と意味解析の分離

- 一気に分離しようと11コミットぐらいしたらセグフォしたので、やはり段階的にやっていく。演算子の優先順位は多いので、ひたすら作業となる。

- 純粋なパーサーがParserStateを見なくなった。じゃあこれ意味解析器の状態であってParserStateじゃないやん。

- 純粋な意味解析器を作ろうと7コミットしたらまた詰まったので調査。parse_typecheckとtypecheckが果たして同じ木を吐くかどうか確認したところ、カテゴリにBINARY_EXPR付け忘れているだけだと判明。

- しかしやはり木が一致しない。POINTER_PLUS_INTが左右入れ替えている可能性があるのをすっかり忘れていたので、それを無視して再実験。

- とりあえず後置演算子周りが怪しいことが判明したので一旦寝よう

## 2018年8月16日 (Day 36; Seccamp Day 3)

- 起きた。バグを直した。後置++と後置--に関して意味解析器でノード付け忘れていただけだった。

- parse_typecheck系の関数の廃止に成功。

- デバッグ用の木の比較コードとかを削除。

### struct

- アラインメント、意外と案ずるより産むが易しだった。なるほどこういう仕組みだったのね

- structのパースをするためにアドホックな実装をしていたら泥沼にはまったので、15コミットぐらい戻して6コミットを救出、ちゃんときれいに実装していく。

- sizeofを求めるsize_of関数はコード生成時に今まで2通りに使われていて、一つは「コード生成時に何バイトの命令を用いるか」を求める用途（つまり1か4か8しかない）、もう一つはポインタ演算やグローバル変数確保（つまり任意のサイズがある）のためである。structが増えるとsize情報が動的に増えていくので、前者をsize_of_basic、後者のをsize_ofとすることで、後者にのみstruct情報を渡していけばいいと分かった。

- structのsizeとalignが取れるようになり、structとかstructの配列とかがローカル変数として扱えるようになった。

- まだsizeofがないので、`char *`にキャストしてポインタの差を取る関数をgccでコンパイルすることでテストとする。

- sizeofが欲しくなったのでsizeofを足す

- structの中でstructを使っても動くことを確認。

## 2018年8月17日 (Day 37; Seccamp Day 4)

- パーサーに手を入れて `f(a)[0]++` を許容。

- パーサーにドット演算子とアローを追加。

- なんかバグっていたと思ったら `calloc(1, sizeof(struct TypeAndIdent *))` と書いていた。 `calloc(1, sizeof(struct TypeAndIdent ))` に修正。

- structのメンバアクセスのコード生成に成功。

- gccでコンパイルした構造体と互換性があることを確認するテストを追加することを提案されたので、追加。

- なるほど、expect_typeとかが構造体に未対応か。ParserStateを追加して対応させよう。

### ヌルポインタ

- ヌルポインタ定数を追加。整数式0がポインタへの代入の文脈で出てくる際にヌルポインタ定数に変換。

- 条件系統の演算子が全て4バイトを仮定していたので修正。これでヌルポインタでの条件分岐ができる。

### 三種のvoid

- キーワードvoidを追加。まずは関数の空引数リストのvoidを実装。

- `void *`を実装。

- 返り値voidを実装。

- 少々いじったvector.cのコンパイルに成功。やったぜ。

- [スライド](https://docs.google.com/presentation/d/14ZRNuHFb0jj27kTUri-2VIRm8YY7fJH1R8nXr68uRlI/edit?usp=sharing) を作った。

## 2018年8月18日 (Day 38; Seccamp Day 5)

### switch-case

- switch-caseを実装し始める。

- ParserStateをAnalyzerStateに改名したりする

- caseもdefaultもないswitchを実装（breakはある）。「それはswitchではない」とか言われた（それはそう）

### 焼肉

- RuiさんがCコンパイラ班を連れて焼肉をおごってくださるとのことなので行った。

## 2018年8月19日 (Day 39)

### switch-case

- defaultを実装。

- 定数式評価（整数リテラルのみ対応）を追加。

- caseを実装、Duff's deviceが動く。Duff's deviceは0回のループでは誤作動を起こすことを知った。

### `_Alignof`

- 楽に実装できる`_Alignof`を追加。

## 2018年8月20日 (Day 40)

- コメント足したりリファクタリングしたり。

- 返り値がvoidな関数では`return;`が省略できるように。

### enum

- enumを読む→intとcompatibleにする→名前解決をする→定数式として許す

### 条件分岐

- スカラ型以外を条件式として使えないように。

## 2018年8月21日

### 日記

- 日記を書く。

- あ、ついでにテストケースにクワイン足した

## 2018年8月22日 (Day 41)

### 日記

- とりあえず日記が執筆時刻に追いつく。

# 以上、長い長い回想終わり

### to do

- とりあえずぱっと思いつく段階でのto doを書いておいた。

### switch補足

- `switch` の外で `case` や `default` が出てきたらエラーにするように。エラーにする仕組みのためのメンバーは用意していたのに、処理を入れていなかったという

### nullable vectorの廃止

- Vector.vectorはポインタなので、そこにヌルポインタを入れておくことでnullなVectorを表したりしていた。しかしそんな罠は避けたいし、関数を使わずVector.vectorに対して直に代入するなどもってのほかなので、それを廃止しようとしている。

- `struct`・`enum`（不完全型かもしれない）と関数の引数（引数が空のプロトタイプ宣言であり、情報がないかもしれない）でこのdirty hackを使っていた。`struct`と`enum`については難なく解決。

- 関数の引数について。そもそも、古くからある`FuncInfo`が情報量的に`Type`のサブセットだったので、`FuncInfo`を`Type`に昇格。あと、かつてVectorでなかった名残があったのでそれを廃した。

- そういえばExprもVectorもどきを使っているんだっけ。直さねば。とりあえずargsという単一要素としてまとめる。

- Exprを真のVectorにした。

- さて、関数の引数についてはどうしよう。なんかポインタにしたらバグったのよな。

- フラグを立ててそこで見ることにした。


